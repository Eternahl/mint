const CACHE = '<%= calculate_hash %>'
const PRECACHE_URLS = [
<%= precache_urls.indent(2) %>
]
<%= get_routes %>

// On install precache all static resources
self.addEventListener('install', event => {
  event.waitUntil(
    caches
      .open(CACHE)
      .then(cache =>
        Promise.all(
          PRECACHE_URLS.map(url =>
            cache
              .add(url)
              .catch(error => console.log(`Could not cache: ${url} - ${error}!`))
          )
        )
      )
      .then(() => self.skipWaiting())
  )
})

// On activate remove all unused caches
self.addEventListener('activate', event => {
  event.waitUntil(
    caches
      .keys()
      .then(cacheNames => cacheNames.filter(cacheName => cacheName !== CACHE))
      .then(cachesToDelete =>
        Promise.all(
          cachesToDelete.map(cacheToDelete => caches.delete(cacheToDelete))
        )
      )
      .then(() => self.clients.claim())
  )
})

self.addEventListener('fetch', event => {
  const url = event.request.url
  const origin = self.location.origin
  const isSameOrigin = url.startsWith(origin)

  let response = null

  // If we are on the same origin
  if (isSameOrigin) {
    // Try to get the response from the cache,
    // if not available, check the routing,
    //   if the route exist, serve "index.html" file
    //   else fetch request
    response =
      caches
        .match(event.request)
        .then(cachedResponse =>
          cachedResponse
          ?? (
            isMatchingRoute(event.request)
            ? caches.match('/index.html')
            : fetch(event.request)
          )
        )
  } else {
    response = fetch(event.request)
  }

  event.respondWith(response)
})

function isMatchingRoute(request) { 
  return routes.some( route => {
    const matcher = new RegExp(`^${ route.replace('*','.*') }$`)
    const { pathname } = new URL(request.url)
    return matcher.test(pathname)
  })
}
